import Mux from "@mux/mux-node";
import { NextResponse } from "next/server";

import { currentUser } from "@/lib/auth";
import { db } from "@/lib/db";
import console from "console";

const { video } = new Mux({
  tokenId: process.env.MUX_TOKEN_ID!,
  tokenSecret: process.env.MUX_TOKEN_SECRET!,
});

// Narrow unknown values to strings
const toOptionalString = (value: unknown) =>
  typeof value === "string" ? value : undefined;

// Parse request body regardless of whether it was sent as JSON or multipart
async function parseBody(req: Request) {
  const contentType = req.headers.get("content-type") || "";

  try {
    if (contentType.includes("application/json")) {
      return await req.json();
    }

    if (contentType.includes("multipart/form-data")) {
      const formData = await req.formData();
      return Object.fromEntries(formData.entries());
    }

    // Fallback to JSON parsing
    return await req.json();
  } catch (error) {
    console.error("Failed to parse request body", error);
    return {};
  }
}

// Helper function to process pending audio and subtitle tracks
async function processPendingTracks(
  muxAssetId: string,
  muxDataId: string,
  episodeId: string
) {
  // Find all pending subtitle tracks (have URL but not yet linked to muxData)
  const allSubtitles = await db.subtitleTrack.findMany({
    where: {
      episodeId,
      autoGenerated: false,
    },
  });
  const pendingSubtitles = allSubtitles.filter(
    (sub) => sub.url && !sub.muxTrackId
  );

  // Find all pending audio tracks (have URL but not yet linked to muxData, and not primary)
  // Note: AudioTrack.muxTrackId is required, so we filter by type and check if muxDataId exists
  const allAudioTracks = await db.audioTrack.findMany({
    where: {
      episodeId,
      type: { not: "primary" },
    },
  });

  const pendingAudioTracks = allAudioTracks.filter(
    (audio) => audio.url && !audio.muxDataId
  );

  console.log(
    `Processing ${pendingSubtitles.length} pending subtitles and ${pendingAudioTracks.length} pending audio tracks for asset ${muxAssetId}`
  );

  // Upload pending subtitle tracks to Mux
  for (const subtitle of pendingSubtitles) {
    try {
      if (!subtitle.url) continue;

      const track = await video.assets.createTrack(muxAssetId, {
        language_code: subtitle.languageCode,
        type: "text",
        url: subtitle.url,
        name: subtitle.name,
        text_type: "subtitles",
        closed_captions: false,
      });

      // Update the subtitle record with Mux track info
      // Preserve languageCode and name from the existing record
      await db.subtitleTrack.update({
        where: { id: subtitle.id },
        data: {
          muxTrackId: track.id,
          muxDataId: muxDataId,
          status: track.status || "ready",
          languageCode: subtitle.languageCode,
          name: subtitle.name,
        },
      });

      console.log(
        `Added subtitle track "${subtitle.name}" to Mux asset: ${track.id}`
      );
    } catch (trackError) {
      console.error(
        `Failed to add subtitle track "${subtitle.name}":`,
        trackError
      );
    }
  }

  // Upload pending audio tracks to Mux
  for (const audioTrack of pendingAudioTracks) {
    try {
      if (!audioTrack.url) continue;

      const track = await video.assets.createTrack(muxAssetId, {
        language_code: audioTrack.languageCode,
        type: "audio",
        url: audioTrack.url,
        name: audioTrack.name,
      });

      // Update the audio track record with Mux track info
      // Preserve languageCode and name from the existing record
      await db.audioTrack.update({
        where: { id: audioTrack.id },
        data: {
          muxTrackId: track.id,
          muxDataId: muxDataId,
          status: track.status || "ready",
          languageCode: audioTrack.languageCode,
          name: audioTrack.name,
        },
      });

      console.log(
        `Added audio track "${audioTrack.name}" to Mux asset: ${track.id}`
      );
    } catch (trackError) {
      console.error(
        `Failed to add audio track "${audioTrack.name}":`,
        trackError
      );
    }
  }
}

export async function GET(
  req: Request,
  { params }: { params: Promise<{ seasonId: string; episodeId: string }> }
) {
  try {
    const { seasonId, episodeId } = await params;
    if (!seasonId) {
      return NextResponse.json("Season id not found", { status: 404 });
    }

    const episode = await db.episode.findMany({
      where: {
        id: episodeId,
        isPublished: true,
      },
    });

    return NextResponse.json(episode);
  } catch (error) {
    console.log("[EPISODE_GET]", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function PATCH(
  req: Request,
  {
    params,
  }: {
    params: Promise<{
      seasonId: string;
      episodeId: string;
    }>;
  }
) {
  try {
    const { seasonId, episodeId } = await params;
    const user = await currentUser();
    const body = await parseBody(req);
    const { languageCode: rawLanguageCode, name: rawName, ...values } = body;

    // Support alternate field names in case the client sends different keys
    const languageCode =
      toOptionalString(rawLanguageCode) ??
      (typeof body === "object" &&
      body !== null &&
      "primaryLanguageCode" in body
        ? toOptionalString(
            (body as { primaryLanguageCode?: unknown }).primaryLanguageCode
          )
        : undefined) ??
      (typeof body === "object" && body !== null && "language" in body
        ? toOptionalString((body as { language?: unknown }).language)
        : undefined);
    const name =
      toOptionalString(rawName) ??
      (typeof body === "object" &&
      body !== null &&
      "originalAudioTrackName" in body
        ? toOptionalString(
            (body as { originalAudioTrackName?: unknown })
              .originalAudioTrackName
          )
        : undefined) ??
      (typeof body === "object" && body !== null && "title" in body
        ? toOptionalString((body as { title?: unknown }).title)
        : undefined);

    if (!user || user.role !== "ADMIN") {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const videoUrl = toOptionalString(
      (values as Record<string, unknown>).videoUrl
    );
    const title = toOptionalString((values as Record<string, unknown>).name);

    const episode = await db.episode.update({
      where: {
        id: episodeId,
        seasonId,
      },
      data: {
        ...values,
      },
    });

    if (videoUrl) {
      try {
        // Create Mux asset with extracted language_code and name
        // Audio and subtitle tracks will be added after the asset is ready via webhook
        const subtitles = await db.subtitleTrack.findMany({
          where: {
            episodeId,
          },
        });

        const subtitleInput = subtitles
          .filter((s) => !!s.url)
          .map((sub) => ({
            url: sub.url,
            type: "text" as const,
            text_type: "subtitles" as const,
            language_code: sub.languageCode ?? undefined,
            name: sub.name || "Subtitle",
            closed_captions: false,
          }));

        const asset = await video.assets.create({
          inputs: [
            {
              url: videoUrl,
              language_code: languageCode ?? undefined,
              name: name || "Original",
            },
            ...subtitleInput,
          ],
          video_quality: "premium",
          meta: {
            creator_id: user.id,
            title,
          },
          playback_policies: ["public"],
          // advanced_playback_policies: [
          //   {
          //     drm_configuration_id: process.env.MUX_DRM_CONFIG_ID!,
          //     policy: "drm",
          //   },
          // ],
          max_resolution_tier: "2160p",
          test: false,
        });

        if (!asset.playback_ids || asset.playback_ids.length === 0) {
          throw new Error("No playback IDs returned from Mux");
        }

        const muxData = await db.muxData.upsert({
          where: { episodeId },
          update: {
            assetId: asset.id,
            playbackId: asset.playback_ids[0].id,
          },
          create: {
            episodeId,
            assetId: asset.id,
            playbackId: asset.playback_ids[0].id,
          },
          include: {
            audioTracks: true,
          },
        });

        // Always update primary audio track with languageCode and name from video upload
        // This ensures the primary track reflects the video's language settings
        const primaryTrack =
          muxData.audioTracks?.find((track) => track.type === "primary") ||
          (await db.audioTrack.findFirst({
            where: {
              episodeId,
              type: "primary",
              muxDataId: muxData.id,
            },
          }));

        if (primaryTrack) {
          // Update existing primary track with latest language/name from request or existing values
          await db.audioTrack.update({
            where: { id: primaryTrack.id },
            data: {
              languageCode: languageCode || primaryTrack.languageCode,
              name: name || primaryTrack.name,
              muxTrackId: `primary-${asset.id}`,
            },
          });
        }

        // Process pending tracks immediately (Mux allows adding tracks to 'preparing' assets)
        await processPendingTracks(asset.id, muxData.id, episodeId);

        return NextResponse.json(muxData);
      } catch (muxError) {
        console.error("Error creating Mux asset or saving MuxData:", muxError);
        throw muxError;
      }
    }

    // When no new video is uploaded, we may still need to:
    // 1. update primary audio metadata
    // 2. push any newly uploaded subtitle/audio tracks to the existing Mux asset
    const existingMuxData = await db.muxData.findUnique({
      where: { episodeId },
      include: { audioTracks: true },
    });

    if (languageCode || name) {
      if (existingMuxData) {
        const existingPrimaryTrack =
          existingMuxData.audioTracks.find(
            (track) => track.type === "primary"
          ) ||
          (await db.audioTrack.findFirst({
            where: {
              episodeId,
              type: "primary",
              muxDataId: existingMuxData.id,
            },
          }));

        if (existingPrimaryTrack) {
          await db.audioTrack.update({
            where: { id: existingPrimaryTrack.id },
            data: {
              ...(languageCode && { languageCode }),
              ...(name && { name }),
            },
          });
        }
      }
    }

    // Ensure any pending subtitle/audio tracks added after the asset was created
    // are pushed to Mux when we patch without a new video upload.
    if (existingMuxData?.assetId) {
      await processPendingTracks(
        existingMuxData.assetId,
        existingMuxData.id,
        episodeId
      );
    }

    return NextResponse.json(episode);
  } catch (error) {
    console.log("[SEASON_EPISODE_ID]", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}
