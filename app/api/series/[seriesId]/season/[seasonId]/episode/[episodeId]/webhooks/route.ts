import { db } from "@/lib/db";
import Mux from "@mux/mux-node";
import crypto from "crypto";
import { NextResponse } from "next/server";

const { video } = new Mux({
  tokenId: process.env.MUX_TOKEN_ID!,
  tokenSecret: process.env.MUX_TOKEN_SECRET!,
});

// Helper function to process pending audio and subtitle tracks
async function processPendingTracks(
  muxAssetId: string,
  muxDataId: string,
  episodeId: string
) {
  // Find all pending subtitle tracks (have URL but not yet linked to muxData)
  const allSubtitles = await db.subtitleTrack.findMany({
    where: {
      episodeId,
      autoGenerated: false,
    },
  });
  const pendingSubtitles = allSubtitles.filter((sub) => sub.url && !sub.muxTrackId);

  // Find all pending audio tracks (have URL but not yet linked to muxData, and not primary)
  // Note: AudioTrack.muxTrackId is required, so we filter by type and check if muxDataId exists
  const allAudioTracks = await db.audioTrack.findMany({
    where: {
      episodeId,
      type: { not: "primary" },
    },
  });
  const pendingAudioTracks = allAudioTracks.filter(
    (audio) => audio.url && !audio.muxDataId
  );

  console.log(
    `Processing ${pendingSubtitles.length} pending subtitles and ${pendingAudioTracks.length} pending audio tracks for asset ${muxAssetId}`
  );

  // Upload pending subtitle tracks to Mux
  for (const subtitle of pendingSubtitles) {
    try {
      if (!subtitle.url) continue;

      const track = await video.assets.createTrack(muxAssetId, {
        language_code: subtitle.languageCode,
        type: "text",
        url: subtitle.url,
        name: subtitle.name,
        text_type: "subtitles",
        closed_captions: false,
      });

      // Update the subtitle record with Mux track info
      // Preserve languageCode and name from the existing record
      await db.subtitleTrack.update({
        where: { id: subtitle.id },
        data: {
          muxTrackId: track.id,
          muxDataId: muxDataId,
          status: track.status || "preparing",
          languageCode: subtitle.languageCode,
          name: subtitle.name,
        },
      });

      console.log(
        `Added subtitle track "${subtitle.name}" to Mux asset: ${track.id}`
      );
    } catch (trackError) {
      console.error(
        `Failed to add subtitle track "${subtitle.name}":`,
        trackError
      );
    }
  }

  // Upload pending audio tracks to Mux
  for (const audioTrack of pendingAudioTracks) {
    try {
      if (!audioTrack.url) continue;

      const track = await video.assets.createTrack(muxAssetId, {
        language_code: audioTrack.languageCode,
        type: "audio",
        url: audioTrack.url,
        name: audioTrack.name,
      });

      // Update the audio track record with Mux track info
      // Preserve languageCode and name from the existing record
      await db.audioTrack.update({
        where: { id: audioTrack.id },
        data: {
          muxTrackId: track.id,
          muxDataId: muxDataId,
          status: track.status || "preparing",
          languageCode: audioTrack.languageCode,
          name: audioTrack.name,
        },
      });

      console.log(
        `Added audio track "${audioTrack.name}" to Mux asset: ${track.id}`
      );
    } catch (trackError) {
      console.error(
        `Failed to add audio track "${audioTrack.name}":`,
        trackError
      );
    }
  }
}

async function getRawBody(req: Request): Promise<Buffer> {
  const array = await req.arrayBuffer();
  return Buffer.from(array);
}

function verifyMuxSignature(rawBody: Buffer, signature: string | null) {
  if (!signature) return false;

  const [algo, hash] = signature.split("=");
  const expectedHash = crypto
    .createHmac(algo, process.env.MUX_TOKEN_SECRET!)
    .update(rawBody)
    .digest("hex");

  return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(expectedHash));
}

export async function POST(req: Request) {
  try {
    const rawBody = await getRawBody(req);
    const signature = req.headers.get("mux-signature");

    if (!verifyMuxSignature(rawBody, signature)) {
      return NextResponse.json(
        { error: "Invalid mux signature" },
        { status: 401 }
      );
    }

    const body = JSON.parse(rawBody.toString());
    const { type, data } = body;

    // Handle video.asset.ready event
    if (type === "video.asset.ready") {
      const { id: muxAssetId } = data;

      if (!muxAssetId) {
        return NextResponse.json({ error: "No asset ID provided" }, { status: 400 });
      }

      console.log("Mux asset is ready:", muxAssetId);

      // Find the muxData by assetId
      const muxData = await db.muxData.findFirst({
        where: { assetId: muxAssetId },
        include: {
          episode: true,
        },
      });

      if (!muxData || !muxData.episodeId) {
        console.error("MuxData not found for assetId:", muxAssetId);
        return NextResponse.json(
          { error: "MuxData not found" },
          { status: 404 }
        );
      }

      const episodeId = muxData.episodeId;

      // Process all pending tracks
      await processPendingTracks(muxAssetId, muxData.id, episodeId);

      return NextResponse.json({
        received: true,
        message: "Processed pending tracks for asset",
      });
    }

    return NextResponse.json({ received: true }, { status: 200 });
  } catch (error) {
    console.error("[EPISODE_ASSET_WEBHOOK_POST]", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}
