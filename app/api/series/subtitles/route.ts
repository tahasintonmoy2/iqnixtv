import { currentUser } from "@/lib/auth";
import { db } from "@/lib/db";
import Mux from "@mux/mux-node";
import { NextResponse } from "next/server";

const { video } = new Mux({
  tokenId: process.env.MUX_TOKEN_ID!,
  tokenSecret: process.env.MUX_TOKEN_SECRET!,
});

export async function POST(req: Request) {
  try {
    const user = await currentUser();
    const {
      name,
      url,
      languageCode,
      episodeId,
      mode = "manual",
    } = await req.json();

    if (!user || user.role !== "ADMIN") {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    if (!languageCode || !episodeId) {
      return new NextResponse("Missing required fields", { status: 400 });
    }

    // Manual upload mode - directly create subtitle track without Mux
    if (mode === "manual") {
      if (!url || !name) {
        return new NextResponse("Missing url or name for manual upload", {
          status: 400,
        });
      }

      const muxAsset = await db.muxData.findUnique({
        where: { episodeId },
      });

      if (!muxAsset) {
        return NextResponse.json({ error: "Asset not found" }, { status: 404 });
      }

      const track = await video.assets.createTrack(muxAsset.assetId, {
        language_code: languageCode,
        type: "text",
        text_type: "subtitles",
        name,
        url,
      });

      if (!track.id) {
        return NextResponse.json("Track id not found", { status: 404 });
      }

      const subtitles = await db.subtitleTrack.create({
        data: {
          name,
          languageCode,
          url,
          episodeId,
          status: "ready",
          muxDataId: muxAsset.id,
          muxTrackId: track.id,
          autoGenerated: false,
        },
      });

      console.log("Created manual subtitle:", subtitles.id);
      return NextResponse.json(subtitles);
    }

    // Auto-generate mode - use Mux AI transcription (requires re-creating asset)
    const muxData = await db.muxData.findUnique({
      where: { episodeId },
    });

    if (!muxData) {
      return NextResponse.json(
        { error: "Mux data not found. Please upload a video first." },
        { status: 404 }
      );
    }

    const episode = await db.episode.findUnique({
      where: { id: episodeId },
    });

    if (!episode?.videoUrl) {
      return NextResponse.json(
        { error: "No video URL found for this episode." },
        { status: 404 }
      );
    }

    // Fetch existing manual subtitles to be added to the new asset
    const existingSubtitles = await db.subtitleTrack.findMany({
      where: {
        episodeId,
        autoGenerated: false,
      },
    });

    const manualSubtitleInputs = existingSubtitles
      .filter((sub) => sub.url)
      .map((sub) => ({
        url: sub.url,
        type: "text" as const,
        text_type: "subtitles" as const,
        closed_captions: false,
        language_code: sub.languageCode,
        name: sub.name,
      }));

    // Re-create the asset with AI-generated subtitles configuration
    const asset = await video.assets.create({
      inputs: [
        {
          url: episode.videoUrl, // Source audio language (defaulting to English)
          generated_subtitles: [
            {
              language_code: languageCode,
              name: name || `Auto-generated ${languageCode}`,
            },
          ],
        },
        ...manualSubtitleInputs,
      ],
      video_quality: "premium",
      meta: {
        creator_id: user.id,
        title: name || "Auto-generated Subtitles",
      },
      playback_policies: ["public"],
      max_resolution_tier: "2160p",
      test: false,
    });

    if (!asset.playback_ids || asset.playback_ids.length === 0) {
      throw new Error("No playback IDs returned from Mux");
    }

    // Delete the old asset to avoid duplicates and costs
    if (muxData.assetId) {
      await video.assets
        .delete(muxData.assetId)
        .catch((err) => console.error("Error deleting old Mux asset:", err));
    }

    // Update MuxData with new asset info
    await db.muxData.update({
      where: { id: muxData.id },
      data: {
        assetId: asset.id,
        playbackId: asset.playback_ids[0].id,
      },
    });

    // Create record for the new auto-generated subtitle
    const subtitles = await db.subtitleTrack.create({
      data: {
        name: name || `Auto-generated ${languageCode}`,
        languageCode,
        url: "", // Will be filled by webhook
        episodeId,
        muxDataId: muxData.id,
        status: "processing",
        autoGenerated: true,
      },
    });

    console.log(
      "Re-created Mux asset with auto-generated subtitles:",
      asset.id
    );
    return NextResponse.json(subtitles);
  } catch (error) {
    console.log("[SUBTITLES_POST]", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}
